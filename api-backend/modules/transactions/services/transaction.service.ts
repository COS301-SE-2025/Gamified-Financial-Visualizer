// services/transaction.service.ts
//import { Pool } from 'pg';
import { logger } from '../../../config/logger';
import pool from '../../../config/db';
import { eventBus } from "../../../events/event-bus"

export interface Transaction {
  transaction_id?: number;  // Optional, auto-generated by DB
  account_id: number;
  category_id?: number;  // Optional if using custom_category_id
  custom_category_id?: number;  // Optional if using category_id
  transaction_amount: number;
  transaction_type: 'expense' | 'income' | 'transfer' | 'fee' | 'withdrawal' | 'deposit';
  transaction_name: string;  // Name or description of the transaction
  transaction_date: string;  // ISO date string format (YYYY-MM-DD)
  is_recurring?: boolean;
  linked_goal_id?: number;
  linked_challenge_id?: number;
  budget_id?: number;
  points_awarded?: number;
}

/**
 * Create a new transaction. Auto-generates transaction_id if not provided.
 * Inserts into recurring_transactions if is_recurring = true.
 */
export async function createTransaction(txn: Transaction) {
  const {
    account_id,
    category_id,
    custom_category_id,
    transaction_amount,
    transaction_type,
    transaction_name,
    transaction_date,
    is_recurring = false,
    linked_goal_id,
    linked_challenge_id,
    budget_id,
    points_awarded = 0
  } = txn;

  const client = await pool.connect();
  try {
    await client.query('BEGIN');

    const { rows } = await client.query(
      `SELECT account_balance, user_id FROM accounts WHERE account_id = $1`,
      [ account_id ]
    );
    const currentBalance = Number(rows[ 0 ]?.account_balance ?? 0);
    const user_id = rows[ 0 ]?.user_id;

    let balanceDelta = Math.abs(transaction_amount);
    const deducting = [ 'expense', 'withdrawal', 'fee' ].includes(transaction_type);
    if (deducting) {
      if (transaction_amount > currentBalance) {
        throw new Error("Insufficient funds for this transaction.");
      }
      balanceDelta *= -1;
    }

    const insertTxnSql = `
      INSERT INTO transactions (
        account_id, category_id, custom_category_id, transaction_amount, transaction_type,
        transaction_name, transaction_date, is_recurring,
        linked_goal_id, linked_challenge_id, budget_id, points_awarded
      )
      VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
      RETURNING transaction_id;
    `;
    const txnRes = await client.query(insertTxnSql, [
      account_id,
      category_id || null,
      custom_category_id || null,
      transaction_amount,
      transaction_type,
      transaction_name,
      transaction_date,
      is_recurring,
      linked_goal_id || null,
      linked_challenge_id || null,
      budget_id || null,
      points_awarded
    ]);
    const transaction_id = txnRes.rows[ 0 ].transaction_id;

    const updateBalanceSql = `
      UPDATE accounts
      SET account_balance = account_balance + $1
      WHERE account_id = $2
      RETURNING account_balance;
    `;
    const balanceRes = await client.query(updateBalanceSql, [ balanceDelta, account_id ]);
    const updatedBalance = balanceRes.rows[ 0 ].account_balance;

    if (linked_goal_id && user_id) {
      // Check if a progress entry already exists for this goal and user
      const progressCheck = await client.query(
        `SELECT amount_added FROM goal_progress WHERE goal_id = $1 AND contributor_id = $2`,
        [ linked_goal_id, user_id ]
      );

      if (progressCheck.rowCount === 0) {
        // First log of progress: create a new entry
        await client.query(
          `INSERT INTO goal_progress (goal_id, contributor_id, amount_added)
           VALUES ($1, $2, $3)`,
          [ linked_goal_id, user_id, transaction_amount ]
        );
      } else {
        // Update the existing entry by adding to amount_added
        await client.query(
          `UPDATE goal_progress
           SET amount_added = amount_added + $1
           WHERE goal_id = $2 AND contributor_id = $3`,
          [ transaction_amount, linked_goal_id, user_id ]
        );
      }

      // Update the user's points if points were awarded
      // Award points based on the amount added to the goal (e.g., 1 point per 10 units)
      const pointsPerUnit = 10;
      const calculatedPoints = Math.floor(transaction_amount / pointsPerUnit);

      if (calculatedPoints > 0) {
        await client.query(
          `UPDATE user_points SET total_points = total_points + $1 WHERE user_id = $2`,
          [ calculatedPoints, user_id ]
        );
      }
    }


    if (budget_id && deducting) {
      await client.query(
        `UPDATE budget_categories
        SET current_amount = current_amount + $1
        WHERE budget_id = $2
          AND (
            (category_id = $3 AND $3 IS NOT NULL AND custom_category_id IS NULL)
            OR (custom_category_id = $4 AND $4 IS NOT NULL AND category_id IS NULL)
          )`,
        [ transaction_amount, budget_id, category_id, custom_category_id ]
      );

      const budgetCheckSql = `
        SELECT current_amount, target_amount
        FROM budget_categories
        WHERE budget_id = $1;
      `;
      const budgetCheckRes = await client.query(budgetCheckSql, [ budget_id ]);
      const { current_amount, target_amount } = budgetCheckRes.rows[ 0 ];

      if (current_amount >= target_amount) {
        // Calculate how much over budget the user is
        const overAmount = current_amount - target_amount;
        // Ratio: e.g., 1 point penalty per 10 units over budget (customize as needed)
        const penaltyRatio = 10;
        const penaltyPoints = Math.ceil(overAmount / penaltyRatio);

        // if budget is provided, and is at 100%, penalized the user
        await client.query(
          `UPDATE user_points SET total_points = GREATEST(total_points - $1, 0) WHERE user_id = $2`,
          [ penaltyPoints, user_id ]
        );
        logger.warn(`[TransactionService] User ${user_id} penalized by ${penaltyPoints} points for exceeding budget ${budget_id}`);
      }
    }

    if (is_recurring) {
      await client.query(
        `INSERT INTO recurring_transactions
         (transaction_id, frequency, next_occurrence)
         VALUES ($1, 'monthly', $2)
         ON CONFLICT (transaction_id) DO NOTHING`,
        [ transaction_id, transaction_date ]
      );
    }

    await client.query('COMMIT');

    eventBus.emit('transaction.created', {
      transaction_id,
      account_id,
      amount: transaction_amount,
      category_id,
      type: transaction_type,
      timestamp: transaction_date
    });

    return { transaction_id, updated_balance: updatedBalance };
  } catch (error) {
    await client.query('ROLLBACK');
    logger.error(`[TransactionService] Error creating transaction:`, error);
    throw error;
  } finally {
    client.release();
  }
}



/**
 * Create a new account for a user.
 */
export async function createAccount(
  user_id: number,
  bank_name: string,
  account_name: string,
  account_type: string,
  currency: string,
  account_balance?: number // Optional, can be null
) {
  const insertAccSql = `
    INSERT INTO accounts
      (user_id, bank_name, account_name, account_type, currency, account_balance)
    VALUES ($1, $2, $3, $4, $5, $6)
    RETURNING account_id;
  `;

  try {
    const res = await pool.query(insertAccSql, [
      user_id,
      bank_name,
      account_name,
      account_type,
      currency,
      account_balance || 0, // Default to 0 if not provided
    ]);
    const accId = res.rows[ 0 ].account_id;
    logger.info(`[TransactionService] Created account ID=${accId} for user ${user_id}`);
    return accId;
  } catch (error) {
    logger.error(`[TransactionService] Error creating account for user ${user_id}:`, error);
    throw error;
  }
}

export async function getAccounts(user_id: number) {
  const sql = `SELECT * FROM accounts WHERE user_id = $1;`;
  try {
    const res = await pool.query(sql, [ user_id ]);
    return res.rows;
  } catch (error) {
    logger.error(`[TransactionService] Error fetching accounts for user ${user_id}:`, error);
    throw error;
  }
}

/**
 * Update a transaction's details (name, date, amount, category).
 */
export async function updateTransactionDetails(
  transaction_id: number,
  updates: Partial<{
    transaction_name: string;
    transaction_date: string;
    transaction_amount: number;
    category_id: number;
    custom_category_id: number;
  }>
) {
  const fields: string[] = [];
  const values: any[] = [];
  let idx = 1;

  for (const [ key, value ] of Object.entries(updates)) {
    if (value !== undefined && value !== null) {
      fields.push(`${key} = $${idx}`);
      values.push(value);
      idx++;
    }
  }

  if (fields.length === 0) {
    throw new Error("No valid fields provided for update.");
  }

  const sql = `
    UPDATE transactions
    SET ${fields.join(', ')}
    WHERE transaction_id = $${idx}
    RETURNING *;
  `;

  values.push(transaction_id);

  try {
    const res = await pool.query(sql, values);
    logger.info(`[TransactionService] Updated transaction ID=${transaction_id}`);
    return res.rows[ 0 ];
  } catch (error) {
    logger.error(`[TransactionService] Error updating transaction ${transaction_id}:`, error);
    throw error;
  }
}


/**
 * Fetch a specific account by account_id
 */
export async function getAccountById(account_id: number) {
  const sql = 'SELECT * FROM accounts WHERE account_id = $1';
  try {
    const result = await pool.query(sql, [ account_id ]);
    return result.rows[ 0 ] || null;
  } catch (error) {
    logger.error(`[TransactionService] Error fetching account ID ${account_id}:`, error);
    throw error;
  }
}


export async function getTransactionByAccount(account_id: number) {
  const sql = `SELECT * FROM transactions WHERE account_id = $1 ORDER BY transaction_date DESC;`;
  try {
    const res = await pool.query(sql, [ account_id ]);
    return res.rows;
  } catch (error) {
    logger.error(`[TransactionService] Error fetching transactions for account ${account_id}:`, error);
    throw error;
  }
}

export async function getTransactionByCategory(category_id: number) {
  const sql = `SELECT * FROM transactions WHERE category_id = $1 ORDER BY transaction_date DESC;`;
  try {
    const res = await pool.query(sql, [ category_id ]);
    return res.rows;
  } catch (error) {
    logger.error(`[TransactionService] Error fetching transactions for category ${category_id}:`, error);
    throw error;
  }
}

export async function getTotalSpentPerCategory(user_id: number) {
  const sql = `
    SELECT 
      COALESCE(c.category_name, cc.custom_category_name) AS category,
      SUM(t.transaction_amount) AS total_spent
    FROM transactions t
    JOIN accounts a ON t.account_id = a.account_id
    LEFT JOIN categories c ON t.category_id = c.category_id
    LEFT JOIN custom_categories cc ON t.custom_category_id = cc.custom_category_id
    WHERE 
      a.user_id = $1
      AND t.transaction_type = 'expense'
      AND t.transaction_date >= (CURRENT_DATE - INTERVAL '1 month')
    GROUP BY category
    ORDER BY total_spent DESC;
  `;
  try {
    const res = await pool.query(sql, [ user_id ]);
    return res.rows;
  } catch (error) {
    logger.error(`[TransactionService] Error fetching last month's spending by category for user ${user_id}:`, error);
    throw error;
  }
}



export async function getCategoryNameByID(categoryID: number) {
  const sql = `SELECT category_name FROM categories WHERE category_id = $1;`;
  try {
    const res = await pool.query(sql, [ categoryID ]);
    return res.rows[ 0 ]?.category_name || null;
  } catch (error) {
    logger.error(`[TransactionService] Error fetching category name for ID ${categoryID}:`, error);
    throw error;
  }

}

export async function updateAccountName(account_id: number, account_name: string) {
  const sql = `UPDATE accounts SET account_name = $1 WHERE account_id = $2`;
  try {
    await pool.query(sql, [ account_name, account_id ]);
    logger.info(`[TransactionService] Updated account name for account ID=${account_id}`);
  } catch (error) {
    logger.error(`[TransactionService] Failed to update account name for ID=${account_id}:`, error);
    throw error;
  }
}


export async function deleteAccount(account_id: number, user_id: number) {
  const sql = `DELETE FROM accounts WHERE account_id = $1 AND user_id = $2;`;
  try {
    await pool.query(sql, [ account_id, user_id ]);
    logger.info(`[TransactionService] Deleted account ID=${account_id} for user ${user_id}`);
  } catch (error) {
    logger.error(`[TransactionService] Error deleting account ID=${account_id}:`, error);
    throw error;
  }
}

export async function getTransaction(id: number) {
  const sql = `SELECT * FROM transactions WHERE transaction_id = $1;`;
  try {
    const res = await pool.query(sql, [ id ]);
    return res.rows[ 0 ];
  } catch (error) {
    logger.error(`[TransactionService] Error fetching transaction ${id}:`, error);
    throw error;
  }
}

export async function getUserTransactions(user_id: number) {
  const sql = `
    SELECT
      t.transaction_id,
      t.transaction_amount,
      t.transaction_type,
      a.account_id,
      a.account_name,
      t.transaction_name,
      t.transaction_date,
      c.category_name
    FROM transactions t
    JOIN accounts a ON t.account_id = a.account_id
    LEFT JOIN categories c ON t.category_id = c.category_id
    WHERE a.user_id = $1
    ORDER BY t.transaction_date DESC;
  `;
  try {
    const res = await pool.query(sql, [ user_id ]);
    return res.rows;
  } catch (error) {
    logger.error(`[TransactionService] Error fetching transactions for user ${user_id}:`, error);
    throw error;
  }
}

export async function deleteTransaction(id: number) {
  const sql = `DELETE FROM transactions WHERE transaction_id = $1;`;
  try {
    // restore the account balance
    const balanceSql = `
      UPDATE accounts
      SET account_balance = account_balance + (
        SELECT transaction_amount FROM transactions WHERE transaction_id = $1
      )
      WHERE account_id = (
        SELECT account_id FROM transactions WHERE transaction_id = $1
      );
    `;

    await pool.query(balanceSql, [ id ]);
    await pool.query(sql, [ id ]);
  } catch (error) {
    logger.error(`[TransactionService] Error deleting transaction ${id}:`, error);
    throw error;
  }
}

export async function getBalance(user_id: number) { // adapt to account_balance
  const sql = `
    SELECT COALESCE(SUM(t.transaction_amount),0) AS balance
    FROM transactions t
    JOIN accounts a ON t.account_id = a.account_id
    WHERE a.user_id = $1;
  `;
  try {
    const res = await pool.query(sql, [ user_id ]);
    return Number(res.rows[ 0 ].balance);
  } catch (error) {
    logger.error(`[TransactionService] Error fetching balance for user ${user_id}:`, error);
    throw error;
  }
}

export async function getTransactionByType(transaction_type: string) {
  const sql = `SELECT * FROM transactions WHERE transaction_type = $1 ORDER BY transaction_date DESC;`;
  try {
    const res = await pool.query(sql, [ transaction_type ]);
    return res.rows;
  } catch (error) {
    logger.error(`[TransactionService] Error fetching transactions of type ${transaction_type}:`, error);
    throw error;
  }
}

export async function getExpenseTotalByRange(
  user_id: number,
  startDate: string,
  endDate: string
) {
  const sql = `
    SELECT COALESCE(SUM(t.transaction_amount),0) AS total_expense
    FROM transactions t
    JOIN accounts a ON t.account_id = a.account_id
    WHERE a.user_id = $1
      AND t.transaction_type = 'expense'
      AND t.transaction_date BETWEEN $2 AND $3;
  `;
  try {
    const res = await pool.query(sql, [ user_id, startDate, endDate ]);
    return Number(res.rows[ 0 ].total_expense);
  } catch (error) {
    logger.error(`[TransactionService] Error fetching total expenses for user ${user_id} between ${startDate} and ${endDate}:`, error);
    throw error;
  }
}

export async function getCategories() {
  const sql = `SELECT category_id, category_name FROM categories ORDER BY category_name ASC;`
  try {
    const res = await pool.query(sql);
    return res.rows;
  } catch (error) {
    logger.error(`[TransactionService] Error fetching categories:`, error);
    throw error;
  }
}

/**
 * Budgets: Two-step process: create budget, then allocate category targets
 */
export async function createBudget(
  user_id: number,
  budget_name: string,
  period_start: string,
  period_end: string,
  allocations: Array<{ category_id: number; target_amount: number }>
) {
  const insertBudgetSql = `
    INSERT INTO budgets
      (user_id, budget_name, period_start, period_end)
    VALUES ($1, $2, $3, $4)
    RETURNING budget_id;
  `;
  const client = await pool.connect();
  try {
    await client.query('BEGIN');
    const res = await client.query(insertBudgetSql, [
      user_id,
      budget_name,
      period_start,
      period_end
    ]);
    const budgetId = res.rows[ 0 ].budget_id;

    const insertAllocSql = `
      INSERT INTO budget_categories
        (budget_id, category_id, target_amount)
      VALUES ($1, $2, $3);
    `;
    for (const alloc of allocations) {
      await client.query(insertAllocSql, [
        budgetId,
        alloc.category_id,
        alloc.target_amount
      ]);
    }

    await client.query('COMMIT');
    logger.info(`[TransactionService] Created budget ID=${budgetId} for user ${user_id}`);
    return budgetId;
  } catch (error) {
    await client.query('ROLLBACK');
    logger.error(`[TransactionService] Error creating budget for user ${user_id}:`, error);
    throw error;
  } finally {
    client.release();
  }
}

export async function getBudget(user_id: number) {
  const sql = `
    SELECT b.*, bc.category_id, bc.target_amount
    FROM budgets b
    LEFT JOIN budget_categories bc ON b.budget_id = bc.budget_id
    WHERE b.user_id = $1;
  `;
  try {
    const res = await pool.query(sql, [ user_id ]);
    return res.rows;
  } catch (error) {
    logger.error(`[TransactionService] Error fetching budget for user ${user_id}:`, error);
    throw error;
  }
}

export async function deleteBudget(budget_id: number, user_id: number) {
  const sql = `DELETE FROM budgets WHERE budget_id = $1 AND user_id = $2;`;
  try {
    await pool.query(sql, [ budget_id, user_id ]);
    logger.info(`[TransactionService] Deleted budget ID=${budget_id} for user ${user_id}`);
  } catch (error) {
    logger.error(`[TransactionService] Error deleting budget ${budget_id}:`, error);
    throw error;
  }
}

export async function makeBudgetProgress(budget_id: number, amount: number) {
  const sql = `
    UPDATE budget_categories
    SET current_amount = COALESCE(current_amount, 0) + $1
    WHERE budget_id = $2;
  `;
  try {
    await pool.query(sql, [ amount, budget_id ]);
    logger.info(`[TransactionService] Updated budget ID=${budget_id} with progress of ${amount}`);
  } catch (error) {
    logger.error(`[TransactionService] Error updating budget progress for ID=${budget_id}:`, error);
    throw error;
  }
}


export async function updateBudget(
  budget_id: number,
  fields: Partial<{ budget_name: string; period_start: string; period_end: string }>
) {
  const sets: string[] = [];
  const vals: any[] = [];
  let idx = 1;
  for (const [ key, value ] of Object.entries(fields)) {
    sets.push(`${key} = $${idx}`);
    vals.push(value);
    idx++;
  }
  if (!sets.length) return;

  const sql = `
    UPDATE budgets SET ${sets.join(', ')} WHERE budget_id = $${idx};
  `;
  try {
    await pool.query(sql, [ ...vals, budget_id ]);
    logger.info(`[TransactionService] Updated budget ID=${budget_id}`);


  } catch (error) {
    logger.error(`[TransactionService] Error updating budget ${budget_id}:`, error);
    throw error;
  }
}

/* export async function getBudgetsSummary(user_id: number) {
  const sql = `
  SELECT b.budget_id, b.budget_name, b.period_start, b.period_end,
         COALESCE(SUM(bc.target_amount), 0) AS total_target
  FROM budgets b
  LEFT JOIN budget_categories bc ON b.budget_id = bc.budget_id
  WHERE b.user_id = $1
  GROUP BY b.budget_id;
`;
  try {
    const res = await pool.query(sql, [user_id]);
    return res.rows;
  } catch (error) {
    logger.error(`[TransactionService] Error fetching budgets for user ${user_id}:`, error);
    throw error;
  }
} 
*/

export async function getBudgetsSummary(user_id: number) {
  const sql = `
SELECT 
  b.budget_id, 
  b.budget_name, 
  b.period_start, 
  b.period_end,
  COALESCE(SUM(bc.target_amount), 0) AS total_target,
  COALESCE((
    SELECT SUM(t.transaction_amount)
    FROM transactions t
    WHERE t.budget_id = b.budget_id
  ), 0) AS used
FROM budgets b
LEFT JOIN budget_categories bc ON b.budget_id = bc.budget_id
WHERE b.user_id = $1
GROUP BY b.budget_id;
  `;
  try {
    const res = await pool.query(sql, [ user_id ]);
    return res.rows;
  } catch (error) {
    logger.error(`[TransactionService] Error fetching budgets for user ${user_id}:`, error);
    throw error;
  }
}

export async function createBudgetWithCategoryName(
  user_id: number,
  category_id: number,
  allocations: Array<{ category_id: number; target_amount: number }>
): Promise<number> {
  const client = await pool.connect();
  try {
    await client.query('BEGIN');

    const { rows } = await client.query(
      'SELECT category_name FROM categories WHERE category_id = $1',
      [ category_id ]
    );
    const budget_name = rows[ 0 ]?.category_name;
    if (!budget_name) {
      throw new Error('Category not found for the given category_id');
    }

    const today = new Date();
    const start = today.toISOString().split('T')[ 0 ];
    const nextMonth = new Date(today);
    nextMonth.setMonth(nextMonth.getMonth() + 1);
    nextMonth.setDate(nextMonth.getDate() - 1);
    const end = nextMonth.toISOString().split('T')[ 0 ];

    const insertBudget = `
      INSERT INTO budgets (user_id, budget_name, period_start, period_end)
      VALUES ($1, $2, $3, $4)
      RETURNING budget_id;
    `;
    const result = await client.query(insertBudget, [ user_id, budget_name, start, end ]);
    const budget_id = result.rows[ 0 ].budget_id;

    const insertAlloc = `
      INSERT INTO budget_categories (budget_id, category_id, target_amount)
      VALUES ($1, $2, $3);
    `;
    for (const alloc of allocations) {
      await client.query(insertAlloc, [ budget_id, alloc.category_id, alloc.target_amount ]);
    }

    await client.query('COMMIT');
    logger.info(`[BudgetService] Created budget ID=${budget_id} for user ${user_id}`);
    return budget_id;
  } catch (error) {
    await client.query('ROLLBACK');
    logger.error('[BudgetService] Failed to create budget:', error);
    throw error;
  } finally {
    client.release();
  }
}

export async function getBudgetsByUser(user_id: number) {
  const sql = `
    SELECT
      b.budget_id,
      b.budget_name
    FROM budgets b
    WHERE b.user_id = $1
  `;

  try {
    const res = await pool.query(sql, [ user_id ]);
    return res.rows;
  } catch (error) {
    logger.error(`[BudgetService] Error fetching budgets for user ${user_id}:`, error);
    throw error;
  }
}

//===========================================

export async function updateBudgetName(budget_id: number, budget_name: string, user_id: number) {
  const sql = `UPDATE budgets SET budget_name = $1 WHERE budget_id = $2 AND user_id = $3;`;
  try {
    const result = await pool.query(sql, [ budget_name, budget_id, user_id ]);
    if (result.rowCount === 0) {
      throw new Error('Budget not found or unauthorized');
    }
    logger.info(`[TransactionService] Updated budget name for budget ID=${budget_id}`);
  } catch (error) {
    logger.error(`[TransactionService] Error updating budget name for ID=${budget_id}:`, error);
    throw error;
  }
}

